<?xml version="1.0" encoding="UTF-8"?>
<org.eclipse.epf.uma:ContentDescription xmi:version="2.0" xmlns:xmi="http://www.omg.org/XMI" xmlns:org.eclipse.epf.uma="http://www.eclipse.org/epf/uma/1.0.6/uma.ecore" xmlns:epf="http://www.eclipse.org/epf" epf:version="1.5.1" xmi:id="-1xE2ZW3MjNAJ7jkaZNbkww" name="visual_modeling,_1fM3AC9_EduW5uTjiIcspQ" guid="-1xE2ZW3MjNAJ7jkaZNbkww" changeDate="2006-11-21T17:21:26.464-0200" version="1.0.0">
  <mainDescription>&lt;h3>Introdução&lt;/h3>&#xD;
&lt;p>O uso de técnicas visuais de modelagem para projetar o software pode ajudar a transformar problemas complexos em uma série de problemas menores, mais fáceis para as tarefas de gestão. Compartilhar imagens, em vez de documentos escritos ou código fonte também contribui para o entendimento e comunicação de conceitos difíceis. A adoção de notações padrão de modelagem como a UML aumenta essa capacidade, ajudando a construir diagramas precisos e inequívocos.&lt;/p>&#xD;
&lt;p>O grau de formalidade usada quando da produção e divulgação de modelos devem variar de acordo com as suas necessidades. Equipes pequenas e colaborativas modelando em quadros brancos e capturando os resultados em folhas de papel ou com câmeras digitais podem produzir bons resultados. Isto também pode ajudar a equipe a focar na produção de software com a ajuda de modelos, em vez de se tornar despropositada com excesso de engenharia nos modelos e nas soluções. As ferramentas de modelagem fornecem valor adicional aos projetos, em especial para sistemas mais complexos. Entretanto, as suas especificações de uso estão fora do escopo desta diretriz.&lt;/p>&#xD;
&lt;p>Esta diretriz não descreve uma progressão sequencial formal através de etapas prescritivas de design. Se alguma ou todas estas técnicas são necessárias, ou quanto tempo é gasto com elas é uma incógnita que depende de questões do mundo real tais como a complexidade dos requisitos, a experiência do designer, bem como a forma como a equipe trabalha.&lt;/p>&#xD;
&lt;p>Esta diretriz usa um cenário simplificado (Login) para ajudar a manter o foco na compreensão das técnicas, e não nos requisitos específicos. No mundo real, é duvidoso que muito tempo seja gasto na modelagem de um simples problema. Segue abaixo o diagrama de caso de uso, para referência;&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;142&quot; alt=&quot;Modelo de Caso de Uso User Login&quot; src=&quot;./resources/user_login_ucm.JPG&quot; width=&quot;472&quot; />&#xD;
&lt;/p>&#xD;
&lt;h3>Identifique os elementos&lt;/h3>&#xD;
&lt;p>Desenhe os elementos de design identificados como classes em um diagrama UML. Aplique os estereótipos adequados e opcionalmente desenhe a classe usando um ícone específico de estereótipo para caracterizar a intenção da classe no design. Nomeie e descreva resumidamente as classes com poucas frases. Não gaste muito tempo trabalhando em associações, uma vez que estas serão desenvolvidas através do trabalho nas colaborações na próxima etapa.&lt;/p>&#xD;
&lt;p>As classes podem ser desenhadas com um retângulo UML básico ou com um símbolo específico associado a um determinado estereótipo.&lt;/p>&#xD;
&lt;p>O diagrama de classe resultante deverá ser conceitualmente semelhante a este:&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;228&quot; alt=&quot;Identificar Elementos - Modelo de Classe Inicial&quot; src=&quot;./resources/identify_elements_bce.JPG&quot;     width=&quot;290&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>Para este exemplo, o &lt;a class=&quot;elementLink&quot; href=&quot;./../../../openup/guidances/guidelines/entity_control_boundary_pattern_C4047897.html&quot; guid=&quot;_uF-QYEAhEdq_UJTvM1DM2Q&quot;>Padrão Entidade-Controle-Fronteira&lt;/a> foi usado para derivar duas classes (LoginUI e LoginController). Adicionalmente, dois elementos de design já identificados na arquitetura (SecuritySystemInterface e User) também foram incorporados.&lt;/p>&#xD;
&lt;h3>Determine como os elementos colaboram para realizar o cenário&lt;/h3>&#xD;
&lt;p>Quando da determinação das colaborações, dois tipos de diagramas são úteis.&lt;/p>&#xD;
&lt;ul>&#xD;
    &lt;li>Um diagrama de objeto dinâmico , mostrando como os elementos de design colaboram para realizar os requisitos.&lt;/li>&#xD;
    &lt;li>Um diagrama de classe estático, mostrando as classes envolvidas na realização dos requisitos.&lt;/li>&#xD;
&lt;/ul>&#xD;
&lt;p>Lembre-se também de atualizar qualquer outro diagrama afetado, com base nas alterações ou inclusões feitas no design.&lt;/p>&#xD;
&lt;p>Crie uma série de diagramas de objeto dinâmicos que mostram como um conjunto de objetos colabora para executar o comportamento dos cenários. Mesmo que apenas um cenário esteja sendo projetado, podem ser necessários vários diagramas para mostrá-lo em partes menores e compreensíveis ou sob vários contextos.&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img style=&quot;WIDTH: 776px; HEIGHT: 355px&quot; height=&quot;355&quot; alt=&quot;Diagrama de Seqüência de User Login&quot;     src=&quot;./resources/user_login_seq.JPG&quot; width=&quot;776&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>O diagrama de seqüência acima mostra as credenciais do usuário passadas ao sistema de segurança para autenticação. Os passos no cenário do caso de uso são transformados em mensagens entre os objetos participantes. As mensagens neste exemplo não estão ainda completamente formadas (não existem parâmetros ou valores de retorno), então elas estão com o prefixo &quot;//&quot; para mostrar que é necessário mais trabalho. Um diagrama de seqüência foi usado neste exemplo, mas um diagrama de comunicação poderia ter sido usado.&lt;/p>&#xD;
&lt;p>Ele pode ser útil para criar um ou mais diagramas de classe estáticos que mostram as classes no design que suportam a realização. Estes diagramas de classe são normalmente chamados de diagramas de Visão das Classes Participantes, eles fornecem uma visão focada no design global mostrando apenas as classes, relacionamentos, operações e atributos relevantes para a colaboração.&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;469&quot; alt=&quot;Visão das Classes Participantes - Login&quot; src=&quot;./resources/login_vopc.jpg&quot; width=&quot;448&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>Este diagrama mostra as operações e os relacionamentos que foram identificadas ao desenhar o diagrama de seqüência. Os relacionamentos neste exemplo ainda não foram refinados, sendo assim eles são exibidos como simples associações. Lembre-se de examinar o diagrama para verificar se o design pode suportar o comportamento do diagrama de seqüência.&lt;/p>&#xD;
&lt;p>Trabalhar o modelo neste nível de detalhe durante a fase inicial do projeto pode ser útil. Ele mantém os diagramas relativamente simples e fáceis de compreender. Ele torna-os mais fáceis de desenhar em uma reunião de trabalho e mais fáceis de alterar durante o processo de discussão. Geralmente é mais fácil de acrescentar o detalhe quando há acordo sobre o essencial.&lt;/p>&#xD;
&lt;h3>Refine as decisões de design&lt;/h3>&#xD;
&lt;p>Uma vez que a parte fundamental do design esteja relativamente estável, você pode começar a adicionar detalhes a ele. Alguns destes podem ser feitos no código ou no modelo. Se for escolhido no modelo, então refine os atributos, as responsabilidades e os relacionamentos.&lt;/p>&#xD;
&lt;h4>Descreva as responsabilidades&lt;/h4>&#xD;
&lt;p>As responsabilidades das classes são ações que deverão ser executadas por um objeto ou o conhecimento mantido e fornecido para outros objetos. Cada classe normalmente possuirá várias responsabilidades; cada responsabilidade irá evoluir para uma ou mais operações durante o design.&lt;/p>&#xD;
&lt;p>As responsabilidades são derivadas das mensagens nos diagramas de interação ou dos requisitos não-funcionais que uma classe tem que suportar. Documente a responsabilidade, dando-lhe um nome, e opcionalmente uma descrição resumida (o que ela faz).&lt;/p>&#xD;
&lt;p>Estas operações podem se tornar auto-evidentes a partir de seu contexto, elas podem dar descrições textuais do algoritmo necessário para executar o comportamento, ou podem gerar um outro passo completo desta técnica onde um grupo de classes que colaboram entre si para executar as partes internas da operação são identificadas, etc.&lt;/p>&#xD;
&lt;h4>Descrever atributos e associações&lt;/h4>&#xD;
&lt;p>Uma classe pode ter que armazenar dados simples, tais como: texto, inteiro, e coisas do gênero. Para tal tipo de dado, os atributos são definidos para as classes. Para um atributo mais complexo ou &quot;comportamental&quot;, considere a criação de uma classe extra e estabeleça uma associação para ela.&lt;/p>&#xD;
&lt;p>Para exercer as suas responsabilidades, as classes podem depender de outras classes que forneçam o comportamento necessário. Essas outras classes podem ser aquelas já identificadas nesta sessão de design, podem ser classes existentes retiradas da arquitetura, ou a criação de novas classes pode ser necessária. As associações em um diagrama de classe podem ser usadas para representar os relacionamentos entre as classes.&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;439&quot; alt=&quot;Visão das Classes Participantes - Login (refinado)&quot; src=&quot;./resources/login_vopc_refined.jpg&quot; width=&quot;557&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>Este diagrama mostra uma série de aperfeiçoamentos. A classe LoginUI foi substituída pela LoginForm. A classe User foi renomeada para UserCredentials e é criada pela classe LoginForm, ao invés de LoginController. Ela é então usada como parâmetro para as mensagens subseqüentes ao invés de passar os atributos individuais. A classe SecuritySystemInterface foi refinada em dois elementos, ISystemSecurity, que fornece uma simples fachada para interação com o resto do design; e SecuritySystemProxy, que trata a interação com o sistema de segurança externa.&lt;/p>&#xD;
&lt;h3>Projete as partes internas&lt;/h3>&#xD;
&lt;p>As classes no design são susceptíveis de serem distribuídas entre diferentes pacotes e subsistemas ou componentes.&lt;/p>&#xD;
&lt;p>&#xD;
    &lt;img height=&quot;304&quot; alt=&quot;User Login - Pacotes de Design&quot; src=&quot;./resources/dv_Packaging.JPG&quot; width=&quot;571&quot; />&#xD;
&lt;/p>&#xD;
&lt;p>Neste exemplo, os elementos LoginForm, LoginController e UserCredentials foram colocados em um pacote chamado LocalSecurity. A SecuritySystemProxy é uma parte de um subsistema chamado SecuritySystemAdapter que realiza a interface ISecuritySystem. A SecuritySystemAdapter envolve a SecuritySystem legada, expressa aqui como um componente que oferece a interface validateUser.&lt;/p>&#xD;
&lt;p>Cada um destes elementos de pacote pode ser distribuído entre a equipe para um futuro trabalho de desenvolvimento.&lt;/p>&#xD;
&lt;h3>Conclusão&lt;/h3>&#xD;
&lt;p>Esta diretriz percorreu as técnicas de forma concreta começando com um cenário de um caso de uso até a distribuição das classes identificadas em um conjunto de pacotes. Este exemplo demonstra uma técnica para projetar visualmente, mas deve ser considerado apenas como um passo conceitual de design. Uma pessoa pode facilmente aplicar esta técnica na definição das partes internas da classe SecuritySystemProxy, mostrando a forma como ela irá colaborar com um conjunto de classes para validar as credenciais.&lt;/p>&#xD;
&lt;p>Ao aplicar esta diretriz, trabalhe em pequenos pedaços e lembre-se da meta de entregar software que forneça valor aos usuários. Para entregar software de alta qualidade é necessária a consideração de como as peças vão trabalhar em conjunto para entregar esse valor. Mas logo que decisões importantes forem tomadas e comunicadas aos membros da equipe, estes deverão começar a implementação do código fonte para verificar o design e entregar o valor.&lt;/p></mainDescription>
</org.eclipse.epf.uma:ContentDescription>
